<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>AE1PGA Lab 9</title>

		<meta name="description" content="AE1PGA Lab 9">
		<meta name="author" content="Paul Dempster">

	</head>

	<body>

	  <h1>AE1PGA Lab 9</h1>

	  <h2>Word-guessing game from dictionary</h2>
	  <p>In Lab 6, one of the tasks was to create a word guessing game (Hangman).  When the program was run, the first stage was for 
	  the user to type in all the possible words to randomly pick from.  This is rather tedious.  Normally, it can be any possible 
	  word in the dictionary.  Luckily for us, Linux distributions normally have a dictionary text file which contains all the words 
	  in the dictionary, 1 word per line.  This is stored at "<code>/usr/share/dict/words</code>".  Be aware that there might be 
	  some non-English characters in the dictionary; if you treat each character as just an ASCII code between 0-255 it will be fine.  
	  I suggest filtering them in your program to only use the representing letters 'a' - 'z'.
	  </p>
	  <p>Create a copy of your Lab 6 program and then modify it so that it reads all the words from the dictionary file into the program, 
	  then randomly chooses from them each time a new game starts.
	  </p>
	  <hr />
<!--	 <p> ---------------------  Advanced exercises  ---------------------------</p>
	  <h2>Graphs</h2>
	  <p>
	    Create both an adjacency-matrix and adjacency-list implementation of a directed, unweighted graph data-structures.  
		Each data-structure should support operations similar to the ones defined for other data-structures: create a graph, 
		destroy a graph, add vertex/edge, remove vertex/edge, does vertex exist, does edge between two vertices exist, get 
		all vertices, get all vetices connected to a vertex, is there is path between two vertices, etc.
	  </p>
	  <p>Extension (2-4 hours including research): The <code>graphviz</code> package has a various commands 
	  (<code>dot</code>, <code>neato</code>, <code>twopi</code>, etc) which take a text file describing a graph and generate
	  an image (jpg, png, svg, etc) of that graph.  Add a new function to each graph implementation which takes a filename 
	  and saves a graphviz-formatted text file which describes the graph.  You can find an overview of the file format by 
	  reading the man page (<code>man dot</code>) or by searching online.  You only need a small subset of the language to 
	  be able to save the graph.
	  </p>

	  <h2>Binary Search Tree</h2>
	  <p>
	    Implement a binary-search tree (BST) data-type.  Remember that the difference between a binary tree and a binary search 
		tree is that in the latter, the nodes are stored in a sorted order.  For this exercise, you can make it a BST of 
		<code>int</code> stored in ascending numerical order.  The data-structure should support the following operations:
	  </p>
	  <ul>
	    <li><code>BST *bst_create()</code> that takes no arguments and returns a pointer to a BST type.  You should define 
		the <code>BST</code> data-type however you want.
	    <li><code>int bst_add(BST *root, int val)</code> that takes an existing BST created by <code>bst_create</code> and 
		a new value, and adds that value to the tree.  It should return true/false on success/error.
	    <li><code>int bst_remove(BST *root, int val)</code> that takes an existing BST created by <code>bst_create</code> and 
		a new value, and removes that value to the tree if it exists.  If it is not in the tree then the function should do nothing.  
		It should return true/false on success/error.
	    <li><code>bst_contains(BST *root, int val)</code> that takes an existing BST created by <code>bst_create</code> and a value, 
		and returns true/false if the value is/is not in the tree.
	    <li><code>void bst_destroy(BST *root)</code> that takes an existing BST created by <code>bst_create</code> and frees any 
		memory associated with it.  The pointer to the BST is invalid and should not be used after this function call.
	  </ul>
	  
	  <hr />   -->
	  <br><i>End</i>
	</body>
</html>
